/**********************************************************************************/
/*                                                                                */
/*                                                                               */
/*  DATE                   :May 09, 2014,TIME->15:59:46                                    */
/*  Project name        :SmartNav                                                  */
/*  FileName              :ads7843.c*/
/*  CPU GROUP       :27                                                        */
/*  Designer Engg     : Nithin.P               
/*                                                                                */
/*  This file is generated by Renesas Project Generator (Ver.4.18).      		  */
/*                                     											  */
/**********************************************************************************/

#include "ads7843.h"



#define AdsClock()\
		  __delay_cycles(BIT_DELAY);\
		  DCLK_1; \
		  __delay_cycles(BIT_DELAY);\
	      DCLK_0\
		 

extern struct xEvent e;


static volatile unsigned int ad_result[4];
static volatile unsigned short TP_X,TP_Y;	//touch panel X & Y  12 bits from MSB + LSB

  
  
void WriteADS7843(unsigned char Data)
  {
    unsigned char boucle = 0;
    unsigned char temp = 0;
        
    for(boucle = 0; boucle < 8; boucle++)
      {

        temp = Data >> boucle;
        DIN = temp & 0x01;
		DCLK_1;
		__delay_cycles(100);
		DCLK_0;
		__delay_cycles(100);

      }
    DCLK_0;  
  }  
  
 
unsigned int ReadADS7843(void)
  {
    unsigned int boucle = 0;
    unsigned int Data = 0;
    unsigned int Temp = 0;
        
    for(boucle = 0; boucle < 12; boucle++)
      {
        DCLK_1;
		__delay_cycles(100);
		
        Temp = DOUT; 
	    DCLK_0;
		__delay_cycles(100);
        Temp <<= (12-boucle);  
        Data += Temp;

      }
      
      return Data;
  } 
  
  
void Convert_To_Pixel(unsigned int X, unsigned int Y)
  {
    long Temp;
    
    Temp = X*320/80;
    TP_X = (unsigned int)Temp;
    
    Temp = Y*240/30;
    TP_Y = (unsigned int)Temp;
  }


void Calibrate(int *a,int *b){

	int x = *a;
	int y = *b;
	if (x > 3759)//3750
	 x = 3759;
	 else if (x < 400)
	   x = 400;

	 if (y > 3850)
	   y = 3850;
	 else if (y < 450)
	   y = 450;

	  x = (x - 399) / 14;//13.3
	  y = 320 - ((y - 449) / 10) ;
	  if (x > 240)
		  x = 240;
	 *a = x ;
	 *b = y ;
}  
  
 
    
void Init_ADS7843(void)
  {
	DCLK_0;
	CS_1;
	DIN_1;
	DCLK_1;
	CS_0;
	WriteADS7843(0x0A); 
	ReadFromCharFrom7843();
	CS_1;
	
  }
    
      
 
unsigned int  ReadFromCharFrom7843() //SPI ???   
{   
	unsigned char count=0;   
	unsigned short Num=0;   
	for(count=0;count<12;count++)   
	{   
		Num<<=1;   
		DCLK_1;  
		__delay_cycles(BIT_DELAY);   
		DCLK_0;  
		__delay_cycles(BIT_DELAY);    
		if(DOUT) 
			Num|=0X01;   
	}   
	for(count=0;count<3;count++)   
	{   
		DCLK_1;  __delay_cycles(BIT_DELAY);   
		DCLK_0;  __delay_cycles(BIT_DELAY);    
	}   
    return (Num);   
}   
         
        

void WriteCharTo7843(unsigned char num)    
 {   
 unsigned char count=0;   

 DCLK_0;   
 for(count=0;count<8;count++)   
 {   
 DIN_0;   
 if(num&0X80)
 {
	  DIN_1;   
 }
 DCLK_0; __delay_cycles(BIT_DELAY);  
 DCLK_1; __delay_cycles(BIT_DELAY);   
 num<<=1;   
 }   
 ;   
  
 }       
  
 


 
  
void Read_Position_ADS7843(void)
  {
	unsigned int X, Y;  
    static const unsigned char Cmd_X = 0x90, Cmd_Y = 0xD0;
    

    CS_0;
	
    DCLK_0;

    WriteCharTo7843(Cmd_Y);
    //__delay_cycles(4000); 
	DCLK_1; __delay_cycles(BIT_DELAY);
	DCLK_0; __delay_cycles(BIT_DELAY);
    ad_result[0] = ReadFromCharFrom7843();
	
    WriteCharTo7843(Cmd_X);
	//__delay_cycles(4000);
    DCLK_1; __delay_cycles(BIT_DELAY);
    DCLK_0; __delay_cycles(BIT_DELAY);	
    ad_result[1] = ReadFromCharFrom7843(); 

  }
         
      

 EventPointer getPos(void)
{
static unsigned int Y_Max,Y_Min,X_Max,X_Min;	
static struct xEvent Loc;
		Loc.x		=		0;
		Loc.y		=		0;
		Loc.flag	=		0;
	 	Y_Max		=   	3860;
	 	Y_Min	 	=	    230;
	 	X_Max		=	    3860;
	 	X_Min	 	=	    230;
			
while(!PEN_INT){

 Read_Position_ADS7843();
	

	    if((ad_result[0]>Y_Min && ad_result[0]< Y_Max) && (ad_result[1]> X_Min &&ad_result[1]<X_Max) )
	    {
		   Y_Max 	=	ad_result[0] + 100;	
		   Y_Min 	=	ad_result[0] - 100;
		   X_Max 	=	ad_result[1] + 100;
		   X_Min 	=	ad_result[1] - 100;
	       Loc.x	= 	(ad_result[0]	-  190)/11; 
	       Loc.y	= 	(ad_result[1]	-  300)/14;      
	       Loc.x 	=	320				-    Loc.x;  
		   Loc.y 	=	240				-    Loc.y;  
		   Loc.flag	++;
	    }
	if(Loc.flag>2)
		{
					
		return &Loc;
		}
	}
	
}    
    
    
    
    
    
